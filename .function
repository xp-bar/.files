#!/bin/bash

function hide(){
    tput smcup
    tput sc
    tput cup 0 0
}
function show(){
    tput rc;
    tput rmcup;
}

function dash(){
    if [[ $2 != '' ]]; then
        open dash://$1:{$2}
    else
        open dash://{$1}
    fi
}

function cht() {
    if [[ $@ == *""* ]]; then
        hide;
        tput clear;
        cht.sh --shell;
        wait;
        show;
    else
        cht.sh $@;
    fi
}

source ~/.koolaid

function retag() {
    ctags -R \
        --php-kinds=cft \
        --exclude="node_modules" \
        --exclude="*.js" \
        --exclude="*.md" \
        --exclude="*.blade.php" \
        --languages="php";
    # Remove lines too long for vim
    echo "Removing long lines";
    echo "$(awk 'length<512' tags)" > tags;
}

function launch() {
    open /Applications/$@.app
}

function dirdiff() {
    dirone=$1
    dirtwo=$2

    if [[ $dirone == "" || $dirtwo == "" ]]; then
        echo -e "\e[31mYou need to provide two directories:\e[0m $0 \e[34mdirectory_one \e[33mdirectory_two\e[0m";
        return 1;
    fi

    function _difffunc() {
        git --no-pager diff $(\ls -1d "$dirone"* | sed "s:$dirone::g" | git hash-object -w --stdin) $(\ls -1d "$dirtwo"* | sed "s:$dirtwo::g" | git hash-object -w --stdin);
    }

    clear;

    _difffunc

    fswatch -0 $dirtwo | while read -d "" event; do
        clear;
        _difffunc
    done
    clear;
    unfunction _difffunc
}

# myip() {
#     myip="$(ifconfig | grep 'inet [0-9.]*' | grep -v '127.0.0.1' | sed 's/inet //g' | sed 's/netmask.*255//g' | tr -d '[:blank:]' | head -n 1)"
#     echo "Your ip address is: "$myip;
#     echo $myip | pbcopy;
# }

whathavewedone() {
    if [[ $1 != "" ]]; then
        target=$1
    else
        target="head"
    fi
    git --no-pager log $target^..head --no-merges --reverse |
        sed '/commit/d' |
        sed '/Author: /d' |
        sed '/Date: /d' |
        sed '/^$/d' |
        sed 's/^[ ]*/- /g' |
        sed 's/\([[:<:]][Cc]hange[d]*[[:>:]]\)/\\\\e[33;1m\1\\\\e[0m/g' |
        sed 's/\([[:<:]][Uu]pdate[d]*[[:>:]]\)/\\\\e[33;1m\1\\\\e[0m/g' |
        sed 's/\([[:<:]][Aa]dd\(ed\)*[[:>:]]\)/\\\\e[32;1m\1\\\\e[0m/g' |
        sed 's/\([[:<:]][Rr]emove[d]*[[:>:]]\)/\\\\e[31;1m\1\\\\e[0m/g' |
        while read in; do echo -e $in; done |
        less
}

function origin() {
    git remote -v -- | sed 's/^.*git@github.com://g' | sed 's/.git.*$//g' | tr -s " " | awk '!seen[$0]++'
}

function branches(){
    echo -e "\n \e[31mBRANCHES:\e[0m";
    git --no-pager branch | sed 's/[\*]*[ ]//g' | sed 's/^/ - /g' | grep -v $(git this);
    echo "";
}

function rh(){
    git ls-remote --heads origin $(git rev-parse --abbrev-ref HEAD)  | grep $(git rev-parse --abbrev-ref HEAD) | sed 's/refs\/heads\/'$(git this)'//g' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'; 
}

function e(){
    typeset -A dotfiles_that_source=(
        a alias
        f function
        i ignore
        z zshrc
    );
    for key value in ${(kv)dotfiles_that_source}; do
        if [[ $1 = $key ]]; then
            tput sc;
            tput cuf 2;
            tput cuu1;
            echo -e "Editing \e[33m~/.$value\e[0m..."
            tput rc;
            sleep 0.2;
            nvim ~/.$value;
            source ~/.$value;
            tput sc;
            tput cuf 2;
            tput cuu1;
            echo -e "Sourced \e[32m~/.$value\e[0m!               "
            tput rc;
        fi
    done
    typeset -A dotfiles_that_dont_source=(
        v vimrc
        t tmux.conf
    );
    for key value in ${(kv)dotfiles_that_dont_source}; do
        if [[ $1 = $key ]]; then
            tput sc;
            tput cuf 2;
            tput cuu1;
            echo -e "Editing \e[33m~/.$value\e[0m..."
            tput rc;
            sleep 0.2;
            nvim ~/.$value;
            tput sc;
            tput cuf 2;
            tput cuu1;
            echo -e "Edited \e[32m~/.$value\e[0m!                "
            tput rc;
        fi
    done
}

function isdown(){
    hide;
    tput sc;
    tput cup 5 5;
    curl $1 -s -f -o /dev/null && echo -e "\e[32m$1 is up!" || echo  -e "\e[31m$1 is down...";
    read "?";
    tput rc;
    show;
}

fvim(){
    nvim $(ack -f | fzf --preview "cat {}")
}

# fda - including hidden directories
fda() {
  local dir
  dir=$(find ${1:-.} -type d 2> /dev/null | fzf-tmux +m) && cd "$dir"
}

fd() {
  DIR=`find * -maxdepth 2 -type d -print 2> /dev/null | fzf-tmux` \
    && cd "$DIR"
}

function calc(){
    awk "BEGIN { print $* }";
}

function loader(){
    COLS=$(tput cols);
    AMOUNT=${1:-$COLS};
    AMOUNT=$[$AMOUNT/100*$COLS]
    c;
    hide;
    POS=$[$COLS%2]
    for i in `seq 0 $[$AMOUNT%$COLS]`;
        do
            tput cup $POS $i;
            echo -e '\u2503';
            sleep 0.05;
        done;
    read "?Done!";
    show
}

function fclock() {
    while true;
    do
        clear;
        date '+%I:%M%p' | figlet -r -f chunky | lolcat;
        sleep 60;
    done
}

function di() {
    if [[ $@ == "" ]]; then
        git diff head
    else
        git diff $@
    fi
}

function fdi() {
    local TARGET="head"
    if [[ $@ != "" ]]; then
        TARGET=$@
    fi

    git diff $TARGET -- `git diff $TARGET --name-only | fzf --preview "cat {}"`
}

function idi() {
    setopt localtraps
    function clean_up() {
        tput rc;
        tput rmcup;
        tput clear;
        clear;
        trap - INT
        return;
    }
    trap clean_up INT
    tput smcup;
    tput clear;
    tput sc;
    tput cup 0 0;
    local this=`git rev-parse --abbrev-ref HEAD`
    local base_branch=`git config repo.base-branch`
    local input=$1
    local base=${base_branch:-"master"}
    local diff_range=${input:-"$base..$this"}

    local files=(${(f)"$(git diff --name-only $diff_range)"})
    local fcount=$#files
    local index=1;

    if [[ $fcount -lt 1 ]]; then
        return 0;
    fi
    for file in $files; do
        echo -e "\n(file \e[33m$index\e[0m of $fcount)";
        tput cup 0 0;
        read -k 1 response\?"View the diff for `echo -e "\e[32m$file\e[0m"`? [y/n/q] "
        case "$response" in
            [yY][eE][sS]|[yY])
                git diff $diff_range -- $file;
                ;;
            [nN][oO]|[nN])
                ;;
            [qQ][uU][iI][tT]|[qQ])
                break
                ;;
            *)
                ;;
        esac
        let "index = $index + 1"
        tput clear;
        tput cuu1;
    done
    clean_up
    unfunction clean_up
}

function din(){
    git --no-pager diff $1 --name-only
}

function tclock(){
    DEFAULT_FONT="mono9"
    if [[ $1 == "" ]]; then
        FONT=$DEFAULT_FONT
    else
        FONT=$1
    fi
    clear;
    while true;
    do
        clear;
        echo -ne "\e[31m"; date '+%I:%M%p' | toilet -f "$(echo -ne $FONT)"; echo -ne "\e[0m";
        sleep 60;
    done
}


# PHP Artisan

function ting(){
    if [[ "$1" ]]; then
        php artisan tinker ting$1.php
    else
        php artisan tinker ting.php
    fi
}

function routes(){
    if [[ "$1" ]]; then
        if [[ "$1" == *"--all"* ]]; then
            php artisan route:list
        else
            php artisan route:list --name="$1"
        fi
    else
        local result="$(php artisan route:list | tail -n +4 | sed 's/| / /' | awk '{print $6}' | grep -v '|' | awk '!seen[$0]++' | fzf)"
        php artisan route:list --name="$result"
    fi
}

# function controllers() {
# }
# | tail -n +4 | sed 's/| / /' | awk '{print $8}' | grep -v '|' | awk '!seen[$0]++'

function views() {
    local view="$(find resources/views -type f | gr --color=none '.blade.php' | fzf --preview 'cat {}')"
    echo $view | pbcopy;
    echo $view
}

function art:cmds(){
    php artisan list --raw | awk -F ' ' '{print $1}' | gr --color=none ':' | fzf | pbcopy
}

function logs() {
    printf '\033[?7h'
    unset files; 
    if [ -t 0 ]; then
        declare -a files
        ls -1 'storage/logs/' | while read in; do
            files+=("storage/logs/$in");
        done
    else
        declare -a files
        while read -r in; do 
            files+=("$in");
        done
    fi
    for file in $files; do
        cat $file | sed -n '/[0-9]*-[0-9]*-[0-9]*/p' | sed '/\.php:[0-9]*/ a \'$'\n\\'$'\n' | grep -v 'Next';
    done | less
}

TODOLIST=~/todo-list.md
function todo(){
    if  [[ "$@" = *"-u"* ]] || [[ "$@" = *"--ugly"* ]]; then
        DISPLAY=cat
    else
        DISPLAY=msee
    fi
    if [[ "$@" != *"--inline"* ]]; then
        hide
    fi
    cp ~/todo-list.md ~/.todo-list.bak >> /dev/null
    if [[ "$@" = *"-e"* ]] || [[ "$@" = *"--edit"* ]]; then
        nvim $TODOLIST
    else
        if [[ "$@" = *"-a"* ]] || [[ "$@" = *"--add"* ]]; then
            echo "- "$2 >> ~/todo-list.md
        fi
        if [[ "$@" = *"--center"* ]]; then
            LINES=$(wc -l < $TODOLIST)
            AVAILABLE=$(tput lines)
            POS=$[$[$[$AVAILABLE - $[$AVAILABLE % 2]]/2] - $[$[$LINES - $[$LINES % 2]]/2]];
            tput cup $[$POS] 0
        fi
        cat $TODOLIST | $DISPLAY
        if [[ "$@" != *"--inline"* ]]; then
            read "?"
        fi
    fi
    if [[ "$@" != *"--inline"* ]]; then
       show
    fi
}

function todoloop(){
    hide;
    todo --inline;
    fswatch -0 $TODOLIST | while read -d "" event
        do
            show;
            hide;
            todo --inline
        done
    show;
}

todorand(){
    todo -u --inline | NOT '#' | sed 's/^- //' | gshuf -n 1 | cowsay | lolcat;
}

# search stack overflow
function stack() {
    INPUT=$1
    read response\?"Search StackOverflow for ${INPUT}? [y/n] "
    # read -r -P "Search StackOverflow for ${INPUT}? [y/n] " response
    case "$response" in
        [yY][eE][sS]|[yY])
        QUERY="${INPUT//' '/+}"
        echo "Sweet, let's do it!"
        sleep 1
        open '/Applications/Vivaldi.app' 'https://stackoverflow.com/search?q='+$QUERY+'&mixed=0'
        ;;
        *)
        echo "Alright, maybe later then."
        ;;
    esac
}


# WEBPACK
function dev(){
	COMPONENT=$1
	if [[ $COMPONENT ]]; then
		npm run dev -- --env.noMaps --env.component=$COMPONENT
	else
		npm run dev -- --env.noMaps
	fi
}

# GIT

function pu(){
    git push -u origin $(git rev-parse --abbrev-ref HEAD);
}

function brwatch(){
    c;
    brstatus --all --inline;
    fswatch -0 .git/refs/heads/ | while read -d "" event;
        do
            c;
            brstatus --all --inline;
        done;
    c;
}

function co() {
    if [[ $@ == "" ]]; then
        git checkout $(git branch | fzf)
    else
        git checkout $(git branch | grep $@ | fzf)
    fi
}

function mg() {
    if [[ $@ == "" ]]; then
        local branch=$(echo `git branch | fzf` | sed 's/[[:space:]]//g')
        read response\?"Do you want to merge "`echo -e "\e[33m$branch\e[0m"`" into "`echo -e "\e[32m$(git rev-parse --abbrev-ref HEAD)\e[0m"`"? [y/n] "
        case "$response" in
            [yy][ee][ss]|[yy])
            git merge $branch
                ;;
            *)
                ;;
        esac
    else
        git merge $@
    fi
}


function brlist(){
        for x in $(br | NOT \* | NOT master | NOT staging | NOT remote);
            do
                if [[ "$@" = *"--notes"* ]] && [[ $(git config branch.$x.note) != "" ]]; then
                    echo -e "$x : \e[31m\e[1m$(git config branch.$x.note)\n\e[0m";
                elif [[ "$@" = *"--notes"* ]] && [[ "$@" != *"--only"* ]]; then
                    echo -e "$x\n";
                elif [[ "$@" = "" ]] || [[ "$@" = *"--inline"* ]]; then
                    echo -e "$x\n";
                fi
        done | less
}

function brcount() {
    i=; git --no-pager branch | while read in; do i=$[i + 1]; done; echo "$i total branches"
}
function brnote(){
    INPUT=$1
    if [[ $INPUT = --all ]]; then
        for x in $(git branch -a | grep -v /); do
            if [[ $(git config branch.$x.note) ]]; then
                echo -e "\033[0;31m${x} \033[0m";
                echo -e "$(git config branch.$x.note)\n";
            fi
        done;
    elif [[ $INPUT = --add ]]; then
        git config branch.$(git symbolic-ref --short HEAD).note "$(git config branch.$(git symbolic-ref --short HEAD).note)
        $2"
    else
        git config branch.$(git symbolic-ref --short HEAD).note $1
    fi
}

function brstatus(){
    INPUT=$1
    if [[ $INPUT = --all ]]; then
        if [[ "$@" != *"--inline"* ]]; then
           hide;
        fi
        echo "\n";
        for x in $(br | NOT master | NOT staging | NOT remote | sed 's/^* //'); do
            if [[ $(git config branch.$x.ready) = *"waiting"* ]]; then
                echo -e "${x} \033[0;33m☉ \033[0m\n";
            elif [[  $(git config branch.$x.ready) = *"ready"* ]]; then
                echo -e "${x} \033[0;32m✓ \033[0m\n";
            else
                echo -e "${x} \033[0;31m✕ \033[0m\n";
            fi
        done;
        if [[ "$@" != *"--inline"* ]]; then
            show
            read "?";
        fi
        if [[ "$@" = *"--looped"* ]]; then
            read "?";
        fi
    else
        git config branch.$(git symbolic-ref --short HEAD).ready $1
    fi
}


function nuke(){
    read response\?"Are you sure you want to nuke your changes? [y/n] "
    case "$response" in
        [yY][eE][sS]|[yY])
        git add . >& /dev/null;
        git reset HEAD --hard >& /dev/null;
            tput cuu1;
            echo "Now at commit: \e[0;31m$(git rev-parse HEAD)                                             ";
            ;;
        *)
            ;;
    esac
}



# function nuke(){
#     read response\?"Are you sure you want to nuke your changes? [y/n] "
#     case "$response" in
#         [yY][eE][sS]|[yY])
#         git add . >& /dev/null;
#         git reset HEAD --hard >& /dev/null;
#         hide;
#             echo "












#             ";
#             tput sc;
#             # tput cuu1;
#             tput cuu1; tput cuu1;
#             sleep 0.05;
#             echo "        {........}";
#             tput cuu1; tput cuu1;
#             sleep 0.05;
#             echo "         {......}";
#             tput cuu1; tput cuu1;
#             sleep 0.05;
#             echo "          {....}";
#             tput cuu1; tput cuu1;
#             sleep 0.05;
#             echo "          {....}";
#             tput cuu1; tput cuu1;
#             sleep 0.05;
#             echo "          {....}";
#             tput cuu1; tput cuu1;
#             sleep 0.05;
#             echo "        {.{....}.}";
#             tput cuu1; tput cuu1;
#             sleep 0.05;
#             echo "     {.{..{....}..}.}";
#             tput cuu1; tput cuu1;
#             sleep 0.05;
#             echo "  {..{..{........}..}..}";
#             tput cuu1; tput cuu1;
#             sleep 0.05;
#             echo "{.{..{...{ BOOM }...}..}.}";
#             tput cuu1; tput cuu1;
#             sleep 0.05;
#             echo "  {..{..{........}..}..}";
#             tput cuu1; tput cuu1;
#             sleep 0.05;
#             echo "   {..{..{......}..}..}";
#             tput cuu1; tput cuu1;
#             sleep 0.05;
#             echo "     {..{..{..}..}..}";
#             tput rc;
#             echo "Now at commit: \e[0;31m$(git rev-parse HEAD)";
#             read "?";
#             show;
#             ;;
#         *)
#             ;;
#     esac
# }

function mkbr(){
    local INPUT=$1
    if [[ $INPUT = "" ]]; then
        echo -e "\e[31mSorry, you need to provide a branch name.";
        return 1;
    fi
    git checkout -b ${INPUT}
    if [[ $? -ne 0 ]]; then
        echo -e "\e[31mSorry, something went wrong there";
        return 1;
    fi
    read remote\?"Does the branch `echo -e "\e[32m$INPUT\e[0m"` already exist as a remote? [y/n] "
    case "$remote" in
        [yY][eE][sS]|[yY])
            git fetch origin
            git branch -u origin/${INPUT} ${INPUT}
            read sync\?"Would you like to sync `echo -e "\e[32m$INPUT\e[0m"` with `echo -e "\e[33morigin/$INPUT\e[0m"`? [y/n] "
            case "$sync" in
                [yY][eE][sS]|[yY])
                    git pull origin ${INPUT}
                    git reset $(rh) --hard
                    ;;
                *)
                    echo "Okay, then."
                    ;;
            esac
            ;;
        *)
            read push\?"Would you like to push `echo -e "\e[32m$INPUT\e[0m"` to origin and add `echo -e "\e[33morigin/$INPUT\e[0m"` as a remote? [y/n] "
            case "$push" in
                [yY][eE][sS]|[yY])
                    git push -u origin ${INPUT}
                    ;;
                *)
                    echo "Okay, then."
                    ;;
            esac
            ;;
    esac
}

function bug() {
    echo "$(echo bugfix-$1 | sed 's/[0-9]//g' | sed 's/\([A-Z]\)/\-\1/g' | tr '[:upper:]' '[:lower:]' | sed 's/ /-/g' | sed 's/://g')" | sed -E 's/[\-]{2,}/-/g'
}

function feat() {
    echo "$(echo feature-$1 | sed 's/[0-9]//g' | sed 's/\([A-Z]\)/\-\1/g' | tr '[:upper:]' '[:lower:]' | sed 's/ /-/g' | sed 's/://g')" | sed -E 's/[\-]{2,}/-/g'
}

function dbr(){
    INPUT=$1
    read response\?"Are you sure you would like to force delete branch ${INPUT}? [y/n] "
    # read -r "Are you sure you would like to force delete branch ${INPUT}? [y/n] " response
    case "$response" in
        [yY][eE][sS]|[yY])
            echo "Deleting branch...";
            git branch -D ${INPUT};
            ;;
        *)
            echo "Branch left untouched."
            ;;
    esac
}

# function rnbr(){
#     INPUT=$1
#     read -r -p "Are you sure you would like to rename branch ${INPUT}? Make sure no one else is working on it! [y/n] " response
#     case "$response" in
#         [yY][eE][sS]|[yY])
#             git branch -m $(parse_git_branch) ${INPUT};
#             echo "Renamed branch to ${INPUT}.";
#             git push origin :$(parse_git_branch) ${INPUT};
#             git push origin -u ${INPUT};
#             echo "Pushed branch to remote."
#             ;;
#         *)
#             echo "Branch left untouched."
#             ;;
#     esac
# }
# export -f rnbr

function brup(){
    git push origin $1
    git branch --set-upstream-to=origin/$1 $1
}

function whic(){
    git diff $1 --name-only
}

function dicount(){
    base_branch="$(git config repo.base-branch)";
    default_branch="$([[ $base_branch != "" ]] && echo $base_branch || echo "master")";
    branch="$([[ $1 != "" ]] && echo $1 || echo $default_branch)";
    local result=`git diff $branch --stat | tail -n 1 | tr , '\n' | sed 's/([+-])//g' | awk '$1=$1'`

    echo $result | while read in; do
        if [[ $in = *"changed"* ]]; then
            echo -e "\e[33m~ $in\e[0m";
        elif [[ $in = *"insertions"* ]]; then
            echo -e "\e[32m+ $in\e[0m";
        elif [[ $in = *"deletions"* ]]; then
            echo -e "\e[31m- $in\e[0m";
        fi
    done
}

function owiwwo(){
    wwiwo | while read in; do atom $in; done
}

function openall(){
    $1 | while read in; do atom $in; done
}

function lsearch() {
    git log --grep=$1
}

function disearch(){
    git diff $2 --name-only | grep $1 | while read in; do git diff $2 -- $in; done
}

function col_line(){
    for i in `seq 0 $[ $(tput cols) * 3 / 4] `; do echo -n "="; done
}

function _prs(){
    #!/bin/bash
    # set -x
    emulate -L bash
    unset URL;
    LOGIN="$(git config user.email):"$GITHUB_TOKEN
    DATE=`date -v-12H +"%Y-%m-%dT%H:%M:%SZ"`
    # TODAY=`date -v-12H +"%Y-%m-%d"`
    USER=$GITHUB_USERNAME
    BASEURL="https://api.github.com/repos/"
    REPO=$GITHUB_REPO
    CREATOR="issues?creator="
    ASSIGNEE="issues?assignee="
    case "$1" in
    "given")
        TITLE="\033[1;37m PULL REQUESTS \033[0;32mCREATED\033[1;37m BY YOU:";
        URL="$BASEURL$REPO$CREATOR$USER";
        ;;
    "assigned")
        TITLE="\033[1;37m PULL REQUESTS \033[0;31mASSIGNED\033[1;37m TO YOU:";
        URL=$BASEURL$REPO$ASSIGNEE$USER;
        ;;
    *)
        ;;
    esac
    if [[ $URL ]]; then
        RESULT=$(curl -s -u $LOGIN $URL);
        LENGTH=$(echo $RESULT | jq '[.]' | jq '[.][][] | length');
        echo -e "\n --------------------------------- \n $TITLE \n ---------------------------------";
		echo -e "\033[0;34m $(echo $URL | sed -E 's/(\/repos)//g' | sed -E 's/(api.)//g' | sed 's/\\//g' | sed -E 's/issues/pulls/g')\n";
        for i in `seq 0 $[$LENGTH - 1]`; do
            echo -e "\033[0;31m $(echo $RESULT | jq -r '[.]' | jq -r '[.][][]['$i'].title')" &&
            echo -e "\033[0;32m $(echo $RESULT | jq -r '[.]' | jq -r '[.][][]['$i'].html_url')" &&
            DATETIME=$(echo $RESULT | jq -r '[.]' | jq -r '[.][][]['$i'].updated_at');
            DATE=$(expr "$DATETIME" : '\(.*\)T');
            echo -e "\033[0;34m Updated: $DATE\033[1;37m \n";
        done
    fi
}

function _labels() {
    #!/bin/bash
    emulate -L bash
    unset URL;
    LOGIN="$(git config user.email):"$GITHUB_TOKEN
    DATE=`date -v-12H +"%Y-%m-%dT%H:%M:%SZ"`
    USER=$GITHUB_USERNAME
    BASEURL="https://api.github.com/repos/"
    REPO=$GITHUB_REPO
    LABELS="labels"
    URL="$BASEURL$REPO$LABELS";

    if [[ $URL ]]; then
        RESULT=$(curl -s -u $LOGIN $URL);
        LENGTH=$(echo $RESULT | jq '[.]' | jq '[.][][] | length');
        for i in `seq 0 $[$LENGTH - 1]`; do
            echo -e "$(echo $RESULT | jq -r '[.]' | jq -r '[.][][]['$i'].name')" &&
        done
    fi
}

function _collabs() {
    #!/bin/bash
    emulate -L bash
    unset URL;
    LOGIN="$(git config user.email):"$GITHUB_TOKEN
    DATE=`date -v-12H +"%Y-%m-%dT%H:%M:%SZ"`
    USER=$GITHUB_USERNAME
    BASEURL="https://api.github.com/orgs/"
    ORG=$GITHUB_ORGANIZATION
    MEMBERS="/members"
    URL=$BASEURL$ORG$MEMBERS;
    COMMAND="curl -s -u $LOGIN $URL"
    if [[ $URL ]]; then
        RESULT=$($COMMAND);
        LENGTH=$(echo $RESULT | jq '[.]' | jq '[.][][] | length');
        for i in `seq 0 $[$LENGTH - 1]`; do
            echo "$(echo $RESULT | jq -r '[.]' | jq -r '[.][][]['$i'].login')";
        done
    fi
}

gpr() {
    function after_pr_hook() {
        declare -a input_lines
        while read -r in; do
            input_lines+=("$in\n");
        done
        local url=`echo $input_lines | tail -n 2 | head -n 1 | sed 's/^[[:space:]]//g'`
        echo $url
    }
    local arg1=$1
    local base=${arg1:-"master"}
    local assigned="$(_collabs | fzf --header='Select an assignee:')"
    if [[ $@ == *"-l"* ]]; then
        local label="$(_labels | fzf --header='Select a label:')"
        # hub pull-request -a $assigned -r $assigned -l $label -b $base | after_pr_hook
        hub pull-request -a $assigned -r $assigned -l $label -b $base
    else
        # hub pull-request -a $assigned -r $assigned -b $base | after_pr_hook
        hub pull-request -a $assigned -r $assigned -b $base
    fi

    unfunction after_pr_hook
}


mkalias(){
    if [[ $1 ]]; then
        echo "alias $1='$2'" >> ~/.extra-aliases
    fi
    source ~/.extra-aliases
}

function fromroman () {
  local max=0 sum i j
  local -A conv
  conv=(I 1 V 5 X 10 L 50 C 100 D 500 M 1000)
  for j in ${(Oas::)1}; do
    i=conv[$j]
    if (( i >= max )); then
      (( sum+=i ))
      (( max=i ))
    else
      (( sum-=i ))
    fi
  done
  echo $sum
}

function toroman() {
  local -a conv
  local number=$1 div rom num out
  conv=(I 1 IV 4 V 5 IX 9 X 10 XL 40 L 50 XC 90 C 100 CD 400 D 500 CM 900 M 1000)
  for num rom in ${(Oa)conv}; do
    (( div = number / num, number = number % num ))
    while (( div-- > 0 )); do
      out+=$rom
    done
  done
  echo $out
}

function tasky() {
    hide;
    tput clear;
    tb $TASKBOOK_ARGS;
    fswatch -0 $TASKBOOK | while (read -d "" event || read "?")
        do
            tput clear;
            tb $TASKBOOK_ARGS;
        done
    show;
}

function icat() {
    local maxWidth="$(tput cols)" 
    local width=
    if [[ $@ == *"--half"* ]]; then
        width=$[$(tput cols)/2]
    elif [[ $@ == *"--quarter"* ]]; then
        width=$[$(tput cols)/4]
    elif [[ $@ =~ '--width=[0-9]*' ]]; then
        width="$(echo $@ | sed -n 's/.*\(\-\-width\=\)\([0-9]*\)/\2/p')"
    else
        width=$maxWidth
    fi
    
    if [[ $width -gt $maxWidth ]]; then
        width=$maxWidth;
    fi

    if [[ $@ == *"--pager"* ]]; then
        imgcat -w $width --256 -H $1 | cat | $PAGER
    else
        imgcat -w $width --256 -H $1 | cat
    fi
}

# unalias z 2> /dev/null
# z() {
  # [ $# -gt 0 ] && _z "$*" && return
  # cd "$(_z -l 2>&1 | fzf --height 40% --nth 2.. --reverse --inline-info +s --tac --query "${*##-* }" | sed 's/^[0-9,.]* *//')"
# }
