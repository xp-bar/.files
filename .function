#!/bin/bash

function hide(){
    tput smcup
    tput sc
    tput cup 0 0
}
function show(){
    tput rc;
    tput rmcup;
}

function dash(){
    if [[ $2 != '' ]]; then
        open dash://$1:{$2}
    else
        open dash://{$1}
    fi
}

function rh(){
    git ls-remote --heads origin $(git rev-parse --abbrev-ref HEAD)  | grep $(git rev-parse --abbrev-ref HEAD) | sed 's/refs\/heads\/'$(git this)'//g' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'; 
}

function e(){
    typeset -A dotfiles_that_source=(
        a alias
        f function
        i ignore
    );
    for key value in ${(kv)dotfiles_that_source}; do
        if [[ $1 = $key ]]; then
            tput sc;
            tput cuf 2;
            tput cuu1;
            echo -e "Editing \e[33m~/.$value\e[0m..."
            tput rc;
            sleep 0.2;
            nvim ~/.$value;
            source ~/.$value;
            tput sc;
            tput cuf 2;
            tput cuu1;
            echo -e "Sourced \e[32m~/.$value\e[0m!               "
            tput rc;
        fi
    done
    typeset -A dotfiles_that_dont_source=(
        v vimrc
        t tmux.conf
        z zshrc
    );
    for key value in ${(kv)dotfiles_that_dont_source}; do
        if [[ $1 = $key ]]; then
            tput sc;
            tput cuf 2;
            tput cuu1;
            echo -e "Editing \e[33m~/.$value\e[0m..."
            tput rc;
            sleep 0.2;
            nvim ~/.$value;
            tput sc;
            tput cuf 2;
            tput cuu1;
            echo -e "Edited \e[32m~/.$value\e[0m!                "
            tput rc;
        fi
    done
}

function isdown(){
    hide;
    tput sc;
    tput cup 5 5;
    curl $1 -s -f -o /dev/null && echo -e "\e[32m$1 is up!" || echo  -e "\e[31m$1 is down...";
    read "?";
    tput rc;
    show;
}

fvim(){
    nvim $(fzf)
}

# fda - including hidden directories
fda() {
  local dir
  dir=$(find ${1:-.} -type d 2> /dev/null | fzf-tmux +m) && cd "$dir"
}

fd() {
  DIR=`find * -maxdepth 2 -type d -print 2> /dev/null | fzf-tmux` \
    && cd "$DIR"
}

function calc(){
    awk "BEGIN { print $* }";
}

function loader(){
    COLS=$(tput cols);
    AMOUNT=${1:-$COLS};
    AMOUNT=$[$AMOUNT/100*$COLS]
    c;
    hide;
    POS=$[$COLS%2]
    for i in `seq 0 $[$AMOUNT%$COLS]`;
        do
            tput cup $POS $i;
            echo -e '\u2503';
            sleep 0.05;
        done;
    read "?Done!";
    show
}

function fclock() {
    while true;
    do
        clear;
        date '+%I:%M%p' | figlet -r -f chunky | lolcat;
        sleep 60;
    done
}

function koolaid(){
    unset files; 
    if [ -t 0 ]; then
        declare -a files
        git --no-pager diff master --diff-filter=d --name-only | grep '.php' | grep -v '.blade.php' |
        while read in; do
            files+=("$in\n");
        done
    else
        declare -a files
        while read -r in; do 
            files+=("$in\n");
        done
    fi
    (for file in $files; do
        filename=$(echo $file | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'); 
        phpcs $filename --colors&;
    done | sed 's/(phpcs $filename -q --colors)//g') | less
}

function koolfix(){
    unset files; 
    if [ -t 0 ]; then
        declare -a files
        git --no-pager diff master --diff-filter=d --name-only -- . ':(exclude)*.blade.php;' |
        while read in; do
            files+=("$in\n");
        done
    else
        declare -a files
        while read -r in; do 
            files+=("$in\n");
        done
    fi
	echo -e "\e[31mFixing...";
    (for file in $files; do
        filename=$(echo $file | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'); 
		phpcbf $filename --colors;
	done) > /dev/null;
	tput cuu1;
	echo -e "\e[32mFixed!                   ";
}

function di() {
    if [[ $@ == "" ]]; then
        git diff head
    else
        git diff $@
    fi
}

function din(){
    git --no-pager diff $1 --name-only
}

function tclock(){
    DEFAULT_FONT="mono9"
    if [[ $1 == "" ]]; then
        FONT=$DEFAULT_FONT
    else
        FONT=$1
    fi
    while true;
    do
        clear;
        date '+%I:%M%p' | toilet -f "$(echo $FONT)" --filter border | lolcat;
        sleep 60;
    done
}


# PHP Artisan

function ting(){
    if [[ "$1" ]]; then
        php artisan tinker ting$1.php
    else
        php artisan tinker ting.php
    fi
}

function routes(){
    if [[ "$1" ]]; then
        if [[ "$1" == *"--all"* ]]; then
            php artisan route:list
        else
            php artisan route:list --name="$1"
        fi
    else
        local result="$(php artisan route:list | tail -n +4 | sed 's/| / /' | awk '{print $6}' | grep -v '|' | awk '!seen[$0]++' | fzf)"
        php artisan route:list --name="$result"
    fi
}

function views() {
    local view="$(find resources/views -type f | gr --color=none '.blade.php' | fzf)"
    echo $view | pbcopy;
    echo $view
}

function art:cmds(){
    php artisan list --raw | awk -F ' ' '{print $1}' | gr --color=none ':' | fzf | pbcopy
}

function logs() {
    printf '\033[?7h'
    unset files; 
    if [ -t 0 ]; then
        declare -a files
        ls -l 'storage/logs/'
        while read in; do
            files+=("$in\n");
        done
    else
        declare -a files
        while read -r in; do 
            files+=("$in\n");
        done
    fi
    for file in $files; do
        cat $file | sed -n '/[0-9]*-[0-9]*-[0-9]*/p' | sed '/\.php:[0-9]*/ a \'$'\n\\'$'\n' | grep -v 'Next';
    done | less
}

TODOLIST=~/todo-list.md
function todo(){
    if  [[ "$@" = *"-u"* ]] || [[ "$@" = *"--ugly"* ]]; then
        DISPLAY=cat
    else
        DISPLAY=msee
    fi
    if [[ "$@" != *"--inline"* ]]; then
        hide
    fi
    cp ~/todo-list.md ~/.todo-list.bak >> /dev/null
    if [[ "$@" = *"-e"* ]] || [[ "$@" = *"--edit"* ]]; then
        nvim $TODOLIST
    else
        if [[ "$@" = *"-a"* ]] || [[ "$@" = *"--add"* ]]; then
            echo "- "$2 >> ~/todo-list.md
        fi
        if [[ "$@" = *"--center"* ]]; then
            LINES=$(wc -l < $TODOLIST)
            AVAILABLE=$(tput lines)
            POS=$[$[$[$AVAILABLE - $[$AVAILABLE % 2]]/2] - $[$[$LINES - $[$LINES % 2]]/2]];
            tput cup $[$POS] 0
        fi
        cat $TODOLIST | $DISPLAY
        if [[ "$@" != *"--inline"* ]]; then
            read "?"
        fi
    fi
    if [[ "$@" != *"--inline"* ]]; then
       show
    fi
}

function todoloop(){
    hide;
    todo --inline;
    fswatch -0 $TODOLIST | while read -d "" event
        do
            show;
            hide;
            todo --inline
        done
    show;
}

todorand(){
    todo -u --inline | NOT '#' | sed 's/^- //' | gshuf -n 1 | cowsay | lolcat;
}

# search stack overflow
function stack() {
    INPUT=$1
    read response\?"Search StackOverflow for ${INPUT}? [y/n] "
    # read -r -P "Search StackOverflow for ${INPUT}? [y/n] " response
    case "$response" in
        [yY][eE][sS]|[yY])
        QUERY="${INPUT//' '/+}"
        echo "Sweet, let's do it!"
        sleep 1
        open '/Applications/Vivaldi.app' 'https://stackoverflow.com/search?q='+$QUERY+'&mixed=0'
        ;;
        *)
        echo "Alright, maybe later then."
        ;;
    esac
}


# WEBPACK
function dev(){
	COMPONENT=$1
	if [[ $COMPONENT ]]; then
		npm run dev -- --env.noMaps --env.component=$COMPONENT
	else
		npm run dev -- --env.noMaps
	fi
}

# GIT

function pu(){
    git push -u origin $(git rev-parse --abbrev-ref HEAD);
}

function brwatch(){
    c;
    brstatus --all --inline;
    fswatch -0 .git/refs/heads/ | while read -d "" event;
        do
            c;
            brstatus --all --inline;
        done;
    c;
}

function co() {
    if [[ $@ == "" ]]; then
        git checkout $(git branch | fzf)
    else
        git checkout $@
    fi
}

function brlist(){
        for x in $(br | NOT \* | NOT master | NOT staging | NOT remote);
            do
                if [[ "$@" = *"--notes"* ]] && [[ $(git config branch.$x.note) != "" ]]; then
                    echo -e "$x : \e[31m\e[1m$(git config branch.$x.note)\n\e[0m";
                elif [[ "$@" = *"--notes"* ]] && [[ "$@" != *"--only"* ]]; then
                    echo -e "$x\n";
                elif [[ "$@" = "" ]] || [[ "$@" = *"--inline"* ]]; then
                    echo -e "$x\n";
                fi
        done | less
}

function brcount() {
    i=; git --no-pager branch | while read in; do i=$[i + 1]; done; echo "$i total branches"
}
function brnote(){
    INPUT=$1
    if [[ $INPUT = --all ]]; then
        for x in $(git branch -a | grep -v /); do
            if [[ $(git config branch.$x.note) ]]; then
                echo -e "\033[0;31m${x} \033[0m";
                echo -e "$(git config branch.$x.note)\n";
            fi
        done;
    elif [[ $INPUT = --add ]]; then
        git config branch.$(git symbolic-ref --short HEAD).note "$(git config branch.$(git symbolic-ref --short HEAD).note)
        $2"
    else
        git config branch.$(git symbolic-ref --short HEAD).note $1
    fi
}

function brstatus(){
    INPUT=$1
    if [[ $INPUT = --all ]]; then
        if [[ "$@" != *"--inline"* ]]; then
           hide;
        fi
        echo "\n";
        for x in $(br | NOT master | NOT staging | NOT remote | sed 's/^* //'); do
            if [[ $(git config branch.$x.ready) = *"waiting"* ]]; then
                echo -e "${x} \033[0;33m☉ \033[0m\n";
            elif [[  $(git config branch.$x.ready) = *"ready"* ]]; then
                echo -e "${x} \033[0;32m✓ \033[0m\n";
            else
                echo -e "${x} \033[0;31m✕ \033[0m\n";
            fi
        done;
        if [[ "$@" != *"--inline"* ]]; then
            show
            read "?";
        fi
        if [[ "$@" = *"--looped"* ]]; then
            read "?";
        fi
    else
        git config branch.$(git symbolic-ref --short HEAD).ready $1
    fi
}


# function nuke(){
#     read response\?"Are you sure you want to nuke your changes? [y/n] "
#     case "$response" in
#         [yY][eE][sS]|[yY])
#         git add . >& /dev/null;
#         git reset HEAD --hard >& /dev/null;
#             echo "Now at commit: \e[0;31m$(git rev-parse HEAD)";
#             ;;
#         *)
#             ;;
#     esac
# }



function nuke(){
    read response\?"Are you sure you want to nuke your changes? [y/n] "
    case "$response" in
        [yY][eE][sS]|[yY])
        git add . >& /dev/null;
        git reset HEAD --hard >& /dev/null;
        hide;
            echo "












            ";
            tput sc;
            # tput cuu1;
            tput cuu1; tput cuu1;
            sleep 0.05;
            echo "        {........}";
            tput cuu1; tput cuu1;
            sleep 0.05;
            echo "         {......}";
            tput cuu1; tput cuu1;
            sleep 0.05;
            echo "          {....}";
            tput cuu1; tput cuu1;
            sleep 0.05;
            echo "          {....}";
            tput cuu1; tput cuu1;
            sleep 0.05;
            echo "          {....}";
            tput cuu1; tput cuu1;
            sleep 0.05;
            echo "        {.{....}.}";
            tput cuu1; tput cuu1;
            sleep 0.05;
            echo "     {.{..{....}..}.}";
            tput cuu1; tput cuu1;
            sleep 0.05;
            echo "  {..{..{........}..}..}";
            tput cuu1; tput cuu1;
            sleep 0.05;
            echo "{.{..{...{ BOOM }...}..}.}";
            tput cuu1; tput cuu1;
            sleep 0.05;
            echo "  {..{..{........}..}..}";
            tput cuu1; tput cuu1;
            sleep 0.05;
            echo "   {..{..{......}..}..}";
            tput cuu1; tput cuu1;
            sleep 0.05;
            echo "     {..{..{..}..}..}";
            tput rc;
            echo "Now at commit: \e[0;31m$(git rev-parse HEAD)";
            read "?";
            show;
            ;;
        *)
            ;;
    esac
}

function mkbr(){
    INPUT=$1
    git checkout -b ${INPUT}
    read response\?"Would you like to push ${INPUT} to origin and add origin/${INPUT} as a remote? [y/n] "
    # read -r "Would you like to push ${INPUT} to origin and add origin/${INPUT} as a remote? [y/n] " responsetwo
        case "$response" in
            [yY][eE][sS]|[yY])
                git push -u origin ${INPUT}
                ;;
            *)
                echo "If you want to later, run pu!"
                ;;
        esac
}

function dbr(){
    INPUT=$1
    read response\?"Are you sure you would like to force delete branch ${INPUT}? [y/n] "
    # read -r "Are you sure you would like to force delete branch ${INPUT}? [y/n] " response
    case "$response" in
        [yY][eE][sS]|[yY])
            echo "Deleting branch...";
            git branch -D ${INPUT};
            ;;
        *)
            echo "Branch left untouched."
            ;;
    esac
}

# function rnbr(){
#     INPUT=$1
#     read -r -p "Are you sure you would like to rename branch ${INPUT}? Make sure no one else is working on it! [y/n] " response
#     case "$response" in
#         [yY][eE][sS]|[yY])
#             git branch -m $(parse_git_branch) ${INPUT};
#             echo "Renamed branch to ${INPUT}.";
#             git push origin :$(parse_git_branch) ${INPUT};
#             git push origin -u ${INPUT};
#             echo "Pushed branch to remote."
#             ;;
#         *)
#             echo "Branch left untouched."
#             ;;
#     esac
# }
# export -f rnbr

function brup(){
    git push origin $1
    git branch --set-upstream-to=origin/$1 $1
}

function whic(){
    git diff $1 --name-only
}

function diffcount(){
    git diff $1 --stat | grep "files changed"
}

function owiwwo(){
    wwiwo | while read in; do atom $in; done
}

function openall(){
    $1 | while read in; do atom $in; done
}

function lsearch() {
    git log --grep=$1
}

function disearch(){
    git diff $2 --name-only | grep $1 | while read in; do git diff $2 -- $in; done
}

function prs(){
    #!/bin/bash
    # set -x
    emulate -L bash
    unset URL;
    LOGIN="$(git config user.email):"$GITHUB_TOKEN
    DATE=`date -v-12H +"%Y-%m-%dT%H:%M:%SZ"`
    # TODAY=`date -v-12H +"%Y-%m-%d"`
    USER=$GITHUB_USERNAME
    BASEURL="https://api.github.com/repos/"
    REPO=$GITHUB_REPO
    CREATOR="issues?creator="
    ASSIGNEE="issues?assignee="
    case "$1" in
    "given")
        TITLE="\033[1;37m PULL REQUESTS \033[0;32mCREATED\033[1;37m BY YOU:";
        URL="$BASEURL$REPO$CREATOR$USER";
        ;;
    "assigned")
        TITLE="\033[1;37m PULL REQUESTS \033[0;31mASSIGNED\033[1;37m TO YOU:";
        URL=$BASEURL$REPO$ASSIGNEE$USER;
        ;;
    *)
        ;;
    esac
    if [[ $URL ]]; then
        RESULT=$(curl -s -u $LOGIN $URL);
        LENGTH=$(echo $RESULT | jq '[.]' | jq '[.][][] | length');
        echo -e "\n --------------------------------- \n $TITLE \n ---------------------------------";
		echo -e "\033[0;34m $(echo $URL | sed -E 's/(\/repos)//g' | sed -E 's/(api.)//g' | sed 's/\\//g' | sed -E 's/issues/pulls/g')\n";
        for i in `seq 0 $[$LENGTH - 1]`; do
            echo -e "\033[0;31m $(echo $RESULT | jq -r '[.]' | jq -r '[.][][]['$i'].title')" &&
            echo -e "\033[0;32m $(echo $RESULT | jq -r '[.]' | jq -r '[.][][]['$i'].html_url')" &&
            DATETIME=$(echo $RESULT | jq -r '[.]' | jq -r '[.][][]['$i'].updated_at');
            DATE=$(expr "$DATETIME" : '\(.*\)T');
            echo -e "\033[0;34m Updated: $DATE\033[1;37m \n";
        done
    fi
}

mkalias(){
    if [[ $1 ]]; then
        echo "alias $1='$2'" >> ~/.extra-aliases
    fi
    source ~/.extra-aliases
}

function fromroman () {
  local max=0 sum i j
  local -A conv
  conv=(I 1 V 5 X 10 L 50 C 100 D 500 M 1000)
  for j in ${(Oas::)1}; do
    i=conv[$j]
    if (( i >= max )); then
      (( sum+=i ))
      (( max=i ))
    else
      (( sum-=i ))
    fi
  done
  echo $sum
}

function toroman() {
  local -a conv
  local number=$1 div rom num out
  conv=(I 1 IV 4 V 5 IX 9 X 10 XL 40 L 50 XC 90 C 100 CD 400 D 500 CM 900 M 1000)
  for num rom in ${(Oa)conv}; do
    (( div = number / num, number = number % num ))
    while (( div-- > 0 )); do
      out+=$rom
    done
  done
  echo $out
}

function tasky() {
    hide;
    tput clear;
    tb $TASKBOOK_ARGS;
    fswatch -0 $TASKBOOK | while (read -d "" event || read "?")
        do
            tput clear;
            tb $TASKBOOK_ARGS;
        done
    show;
}

function icat() {
    local maxWidth="$(tput cols)" 
    local width=
    if [[ $@ == *"--half"* ]]; then
        width=$[$(tput cols)/2]
    elif [[ $@ == *"--quarter"* ]]; then
        width=$[$(tput cols)/4]
    elif [[ $@ =~ '--width=[0-9]*' ]]; then
        width="$(echo $@ | sed -n 's/.*\(\-\-width\=\)\([0-9]*\)/\2/p')"
    else
        width=$maxWidth
    fi
    
    if [[ $width -gt $maxWidth ]]; then
        width=$maxWidth;
    fi

    if [[ $@ == *"--pager"* ]]; then
        imgcat -w $width --256 -H $1 | cat | $PAGER
    else
        imgcat -w $width --256 -H $1 | cat
    fi
}

unalias z 2> /dev/null
z() {
  [ $# -gt 0 ] && _z "$*" && return
  cd "$(_z -l 2>&1 | fzf --height 40% --nth 2.. --reverse --inline-info +s --tac --query "${*##-* }" | sed 's/^[0-9,.]* *//')"
}
